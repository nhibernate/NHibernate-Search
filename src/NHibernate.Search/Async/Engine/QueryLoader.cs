//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Collections;
using NHibernate.Criterion;

namespace NHibernate.Search.Engine
{
    using System.Threading.Tasks;
    using System.Threading;
    public partial class QueryLoader : ILoader
    {

        #region ILoader Members

        public async Task<object> LoadAsync(EntityInfo entityInfo, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            object maybeProxy = await (session.GetAsync(entityInfo.Clazz, entityInfo.Id, cancellationToken));
            // TODO: Initialize call and error trapping

            return maybeProxy;
        }

        public async Task<IList> LoadAsync(EntityInfo[] entityInfos, CancellationToken cancellationToken = default(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            int maxResults = entityInfos.Length;
            if (maxResults == 0) return EMPTY_LIST;
            if (entityType == null) throw new NotSupportedException("EntityType not defined");
            if (criteria == null) criteria = session.CreateCriteria(entityType);

            DocumentBuilder builder = searchFactoryImplementor.DocumentBuilders[entityType];
            string idName = builder.IdentifierName;
            int loop = maxResults / MAX_IN_CLAUSE;
            bool exact = maxResults % MAX_IN_CLAUSE == 0;
            if (!exact) loop++;

            Disjunction disjunction = Restrictions.Disjunction();
            for (int index = 0; index < loop; index++)
            {
                int max = index * MAX_IN_CLAUSE + MAX_IN_CLAUSE <= maxResults ?
                    index * MAX_IN_CLAUSE + MAX_IN_CLAUSE :
                    maxResults;
                IList ids = new ArrayList(max - index * MAX_IN_CLAUSE);
                for (int entityInfoIndex = index * MAX_IN_CLAUSE; entityInfoIndex < max; entityInfoIndex++)
                {
                    ids.Add(entityInfos[entityInfoIndex].Id);
                }
                disjunction.Add(Restrictions.In(idName, ids));
            }
            criteria.Add(disjunction);
            await (criteria.ListAsync(cancellationToken)); // Load all objects

            // Mandatory to keep the same ordering // TODO: Would it be faster to keep the list and then sort it?
            IList result = new ArrayList(entityInfos.Length);
            foreach (EntityInfo entityInfo in entityInfos)
            {
                object element = await (session.LoadAsync(entityInfo.Clazz, entityInfo.Id, cancellationToken));
                if (NHibernateUtil.IsInitialized(element))
                {
                    //all existing elements should have been loaded by the query,
                    //the other ones are missing ones
                    result.Add(element);
                }
                else
                    log.Warn("Lucene index contains info about entity " + entityInfo.Clazz.Name + "#" + entityInfo.Id + " which wasn't found in the database. Rebuild the index.");
            }

            return result;
        }

        #endregion
    }
}